# Ye Olde Fight Club
project-fighting-board-game created by GitHub Classroom

API repositoty located at: https://github.com/csci-49900-01-spring-2019/board-game-rest-api

Website repository located at: https://github.com/csci-49900-01-spring-2019/ye_olde_fighting_game_website

The website itself is located at: https://limitless-wave-13405.herokuapp.com/

<h1>Final Written Report</h1>

<h2>Abstract</h2>
We designed a mobile online competitive multiplayer board game in which players collect weapons and use them to attack other players on the board in an effort to be the last player standing. We also created a website which allows users to view their game stats and the stats of other players. To store the game statistics and user information we built an API, which we connected to both the game and the website. To address security, we created a number of checks in the API ensure incoming data is valid.

<h2>Introduction</h2>
There are a lot of online games out there. But the most popular multiplayer online games require a lot of skill or practice to master, which can be intimidating to new players. Our goal was to design a game with simple rules that would be easy for new players to immediately jump into. However, we also wanted to make sure the game was still fun and engaging. We looked at “.io games” (http://iogames.space/) as a model. These are games that anyone can get started playing easily. We noticed that these games were mostly fast-paced real-time games, and we did not find any turn-based games of this type. So we decided to create a game combining the excitement and action of a fighting game with the strategy and turn-based nature of a board game. 

We all fleshed out the idea for the game together. Truly programmed the much of the player and turn manager classes and coded in basic turn structure, player movement, camera movement, and some tile effects. She also created the website to display game statistics. Yohji worked on implementing the RESTful API, the backend and the deployment to Heroku as well as implementing the networking for the mobile game. He also worked on adding graphics / particles to the game.  Anzhu programmed the tile effects, card system, timer, and the player interface which important information such as the player’s health, current player’s turn, dice roll, timer, and inventory, as well as the inventory button effects.  Anzhu also made code to push player statistics to the RESTful API, as well as code to retrieve an authentication key from the API. Windhaw created the store, a combat log and minor aid in syncing up the tiles, weapon list and tile effects for networking.

<h2>Our Project</h2>
The problem we found, after looking at existing games, is that many online games are complicated and hard to get into. With some games, people have to dedicate lots of time into getting good enough to really compete. The concepts behind these games are interesting and encourage people to start playing, but often it is hard for new players to make much progress. Some existing games already addressed this problem. “.io games”, named because they tend to be hosted on websites with the .io extension, are fast paced and easy to get into. However, these games are similar to each other in many ways. They tend to be real-time games, and are often focused on button mashing (clicking/pressing keys quickly). We wanted to break this mold, but keep the excitement and ease of play of the .io games. Our goal was to create a friendly, easy-to-learn game with a turn based structure more focused on strategy. But we wanted make sure our game was still action-packed and entertaining. 

Our idea was to create an online board game with the theme of fighting. Since many online fighting games involve fighting in real time, we thought it would be an interesting twist to combine a fighting game with a board game. Like a real-time fighting game, we have players trying to attack each other with various weapons, each with different effects. But our game also incorporates the strategy of moving around on a board to maximize the damage you do to other players while also trying to heal or protect yourself from damage dealt to you. This makes our game different from most online fighting games. Our game is also different from most board games, because it is simple to pick up and has very few rules unlike most popular board games today (i.e. Pandemic, Settlers of Catan). Our novel approach is that we mix these two rather different game genres into one product which contains some of the best parts of each.        

The graphics of our game give the feel of playing a board game in a medieval tavern. This is where the game’s name, Ye Olde Fight Club, came from. We wanted this game to feel like the online equivalent of sitting at a table with your friends and striking up some good friendly competition over a board game. Just like we combine two game genres - fighting and board games, we also combine an old medieval aesthetic with a relatively new technology, online networking, to bring the timeless experience of playing board games with friends into the 21st century.         

The final element to our idea is the website, where players can view up-to-date game statistics for themselves and other players. Statistics we collect for each player include: average rank, number of kills, and number of games played, as well as statistics for their performance during individual games. We were inspired by the website op.gg, a website for viewing player stats for various online games. The website is an important part of the game’s experience, because it allows people to check their standing in comparison to other players. This fuels competition, and drives people to play more to improve their stats.

<h2>Technical Details</h2>

**Truly**  

I put much of the basic framework of the game in place in C# using Unity. I began by creating a square-shaped game board with tiles around the edges as Unity GameObjects. I defined the tiles in a doubly-linked circular list, to facilitate the movement of players in either direction from their current tile. I also created a player class and spherical GameObjects to represent the players on the board. And I placed eight Unity cameras around the edges of the board to view the game from. Within the player class, I created a function that is called every time it becomes the player’s turn, using Unity’s coroutines. This function waits for the player to roll the die and move, sends a message to the game manager to check if the player has collided with another player, the function updates the player’s status and waits for the user to press the End Turn button. To allow the player to move, I created a function that moves the player smoothly to the tile they select. This function uses lerp, which linearly interpolates between the player’s origin and destination vectors, making player movement fluid (Unity Technologies). Together, these two functions form the basis of each player’s navigation throughout the board. I also created the Manager class, which handles game issues that require knowledge of all players. Within the Manager class, I implemented functions to check and handle when players are on the same tile, highlight tiles a player can move to, activate tile effects once the player has landed on a tile, and select a camera to view from that is closest to the current player. 

Another important aspect of the project was the website. We fulfilled the multiple native client requirement by having both a mobile game and the game statistics website, both of which connect to the API, which stores all the user data.  I built the website with Ruby on Rails, using the bootstrap-sass gem for CSS and the rest-client gem to connect to the REST API. I created a SessionsController to store the current user and the API auth token. I also created an ActiveRecord table for users, with fields for their main game statistics, and called to the API to update these fields and display other information such as individual game session statistics. One way I built in security to the website was by not storing any passwords locally on the website, and instead sending them (encrypted) directly to the API for verification. I displayed user data in sortable tables using sorttable.js (Langridge).

**Windhaw**  

I began by crafting a bare bones combat system based off of Truly’s existing work on players and the board, simply starting by taking some number off of each player’s health and later creating some archetype weapons. I then made weapon generation random based off arrays of available, pre-chosen, strings that would select a type of weapon and general modifications off of those base weapon types. After weapons and some combat mechanics, I wanted to create something that would record the fights between each player and introduced the combat log into the scene. The UI elements took a while to understand and I eventually made a rectangular panel which sectioned off a portion of a stretch panel to allow the text to be read. The mechanics involved setting the stretch panel to contain a script which made use of its natural text component and make this stretch panel a child of a panel which had a mask and was the child of the topmost panel which had an image component to make a chat panel that was visible in the UI. Naturally the log was scrollable and allowed players to look back on past battles which recorded the player, their damage, the other player being hit and the weapon being used. After experience with the UI from combat log, I created a store which was composed of a separate canvas from the usual UI layout, containing 3 panels, each with a text panel and a button, and a single closing button. The panels were linked to a specific weapon, randomized before opening the store, and displayed its information; name, damage, range and cost. The buttons in each weapon panel judged the difference between the player’s available rubies and the cost of the item, they would make themselves non interactable if this difference was negative.

After fleshing out more of the game, I aided Yohji in a little of his networking; taking advantage of the great strides he’d made and learning off of him how to make his RPC and events to sync up the tiles for all the players, their effects and the composition of the weapon list since these were all generated randomly at the start of the game. This was complicated in that the workaround of using RPCs and events required the conversion of any transferred data into bytes, so no custom objects could be easily passed through. Making use of Truly’s enum for the tile types I was able to pass an the tiles are integers and slowly copy them down from there. As for weapons, I dissected the weapon list to gain each weapon’s name, and its 2 adjectives before passing them all as strings. My work is solely in the confines of the game and ideas of game mechanics.

**Anzhu**  

I began my part of the project by creating a basic tile class which different tiles different tile types and created a function that affects the player in some way when they land on these certain tiles.  For example, a weapon tile, when landed on, gives the player a weapon at random from a list of weapons.  A healing tile adds a certain amount of health to the player that lands on it, and the amount of health is randomized from 10-40.  For the weapon tile specifically, it draws a weapon from random from Windhaw’s weapon List, and also handles the case in which a player has a full inventory when they land on a weapon tile.  When this happens, the weapon they draw is temporarily stored in a weapon object “extraItem.”  The player then has the option of swapping out one of the weapons they currently have for the extraItem, or they can choose to get rid of the item.  

To allow the player to do this, I created 3 buttons, each corresponding to one of the inventory slots.  When a player draws an extraItem, I implemented code such that when an extraItem is drawn, they can simply click the second or third button, and the weapon from that index will be swapped out with the new weapon.  The first index in the inventory is the default weapon, so that cannot be swapped out.  When a player is not in swapping mode, they can also press these buttons to select their current weapon, which is the weapon they will use when they enter combat.  I also implemented a text function to these buttons which displays what weapon they have at that inventory index.  

I worked with the rest of the player interface as well, which displays important game statistics to the user.  Some of this information includes the player’s current health, the dice roll, who’s turn it is, a timer, etc.  I put the function that changes the text in the void update() function, so the text changes in real time.  I coded the timer to deal with players who stop playing the game but leave the game app open.  If a player does not complete their move in a certain time frame, they are kicked out of the game.

I also worked with calling the RESTful API from the game.  I created two classes that do this.  The first class reads the input that is inputted into the login screen, which contains username and password.  My code then connects with the RESTful API and posts the username and password to the API.  If the username and password is valid, the code returns an authentication key, which is stored in the player class to be used for later.  The second class that calls the API posts some player statistics to the API.  To do this, I first had to write code throughout the Manager class and a couple other classes as well that kept track of certain statistics, such as number of kills, number of moves, total damage dealt, etc, and stored these statistics in the Player class.  When the player dies or wins the game, my code then connects to the API and uses the authentication key that was stored earlier when the user logged in to access the API.  My code then posts the player statistics gathered throughout the game to the API..  

**Yohji**  

To fulfill the web service requirement I worked on the RESTful API. I wanted to design a modular API that could bridge the connections between the mobile game and our website. After each game is finished, you push the data via API call to our backend which is a PostgresQL database deployed on Heroku. Then you can make custom API calls from any other client to receive JSON output based on their queries. The API was developed in Ruby on Rails. The first step was to design and normalize the database. We created some ER diagrams and planned out how we wanted to receive the data. Afterwards I worked on implementing the main controllers which was mostly handled by RoR. Next I had to create migrations to alter our tables to fit the relationships we had established i.e setting up foreign keys etc. Then I set up testing and specs using Rspec to validate each entry and test if everything was working properly. This was mainly to introduce consistency within my seeds and other tests as I developed.

Next I implemented authentication using the gems: Bcrypt and JWT. Bcrypt is a rails gem for authentication, it handles the encryption and hashing of the password. JWT is a JSON token that I use to validate each API call. The pipeline is that after the User is authenticated, either a exception for incorrect credentials of a JWT will be returned to the User. With this token the client has access to make API calls. Since every client will have this token, we have security validations that cross-check other clients to see if the incoming information is valid. We decided to go with this approach because we do not have access to the cloud servers we are using for our game. If we did have access, we would only give POST access to that server's token. 

After setting up authentication, I modified the routes and API calls to include querying using parameters. These were typically simple queries such as getting all Game_Sessions that belong to a particular player. Using RoR, the joining of tables is trivial due to the way we created our models. I did not set up any automated testing, however we can manually run all our tests to check if anything broke. 

For the networking of our mobile game we used Photon which is a Unity asset that provides a cloud server. We decided to use this rather than a possible DB approach due to the time-constraints we have. Since our game is deterministic, it would be possible to use a database as our "server" for each move we make, however we deemed that too difficult and probably not worth the extra effort. The only problem would be that Photon is not free after a certain capacity. 

We utilized Photon by creating cloud based rooms that players can enter. The first person to enter a room is defaulted the master client, which acts as a pseudo-authoritative client for any inconsistencies. This master client loads up the Unity scene and starts our "local" game. To add networking into our local game, I mostly leverage RPC(remote procedure calls) and events. I created a networking manager that handles all callbacks and reacts accordingly. For example, if I raised an event that a player took damage, the listening manager would receive that event, check its byteCode and call a local take damage function equal to the parameters passed. To implement this in the local game, I modified the local game code to call events where synchronization was necessary e.g when someone has to move, or take damage. Photon does have an option to encrypt each RPC or event, however I didn't use that as I felt that it was unnecessary. If someone managed to hack our client, the encryption wouldn't help very much. However to counteract this, we thought of possibly checking consistency across all clients in the game. 

<h2>Conclusion</h2>
We are proud of our final project. We have succeeding in creating a functioning online board game, an API to store its data, and a website to display that data in a visually appealing way. Some further work we could do in the future for the game would be to add more items for players to collect and buy besides just weapons. For the website and API, a next step would be to add in two-factor authentication. We could also keep track of more different types of user stats which we could then display on the website. This project taught us about the processes of making a game, website and REST API, and the challenges of connecting them all together. We learned a lot about good code design by rewriting portions of code which later became clunky or redundant. In future projects, we will be able to create better code from the start and we will be more confident in Unity, C#, and Ruby on Rails thanks to our experience with this project. We’ve had a lot of fun (and also some stress) creating Ye Olde Fight Club, and we hope you enjoy it!

<h2>References</h2>
Unity Technologies. “Vector3.Lerp.” Unity, docs.unity3d.com/ScriptReference/Vector3.Lerp.html.  

Wiggins, Adam et al. REST Client -- simple DSL for accessing HTTP and REST resources. Published on GitHub. https://github.com/rest-client/rest-client.  

McDonald, Thomas et. al. Bootstrap 3 for Sass. Published on Libraries.io. https://libraries.io/npm/bootstrap-sass.  

Hartl, Michael. “Chapter 5: Filling in the Layout.” Ruby on Rails Tutorial (Rails 5), 2016, https://www.railstutorial.org/book/filling_in_the_layout.  

Hartl, Michael. “Chapter 8: Basic Login.” Ruby on Rails Tutorial (Rails 5), 2016, www.railstutorial.org/book/basic_login.  

Langridge, Stuart. “sorttable: Make all your tables sortable” Kryogenix, 7 April 2007, https://kryogenix.org/code/browser/sorttable/.  

https://www.pluralsight.com/guides/token-based-authentication-with-ruby-on-rails-5-api

